# 如何做好统一响应格式

现在前后端分离，后端返回数据给前端，但是后端的数据情况是多种多样的，前端拿到数据最佳状态就是做一次判断，知道数据是否有效，因此 前后端应该尽量的约束返回数据的类型和结构

## 链路追踪 RequestId
前后端联调的时候，如果请求数据量大了，很多人一起联调，想要追踪到摸个服务的请求就很麻烦，因此希望能有一个合适的链路追踪的方法。

实现：
- 前端：请求在请求头上，携带 requestId字段，uuid库生成的随机字符串（或者其他库，主要是随机）
- 后端：后端根据 headers 里面的 requestId 将请求写入 到 日志或者链路系统


当前端发现后端返回数据异常，将发起请求的requestId从浏览器f12的network的请求查看，叫后端从日志或者链路系统查找请求参数自己核对

## 常用响应结构
普遍的高级语言能够通过你写回的response 对象的 status，返回错误信息 500 表示 服务端错误这类 => response.message。因此我们只需要关心 status。

响应体结构：
```javascript
interface ResponseBody<T> {
  code: 0 | 1 | number; // 返回的响应状态码，
  message: string;
  data?: T | null
}
```
code和message必须要有，data看响应执行情况，如果没有则为null。

如果你的status常用只有200/500，那么建议把 status 加入到 ResponseBody 里面，不过对应的，可能需要一些转换方法，这里以Koa为例：
```javascript
class ResponseModal<T> implements ResponseBody<T> {
  status: number;
  code: STATUS;
  message: string;
  data: GlobalTS.Null<T>;

  constructor (type: 'success' | 'error', status: number, options: Partial<ResponseBody<T>>) {
    this.status = status
    this.code = type === 'success' ? STATUS.Success : STATUS.Fail
    this.message = ''
    this.data = null
    Object.assign(this, options)
  }

  // 直接返回成功的response
  static success<T> (status: number, options: Partial<ResponseBody<T>>) {
    return new ResponseModal<T>('success', status, options)
  }

  // 直接返回成功的error
  static error<T> (status: number, options: Partial<ResponseBody<T>>) {
    return new ResponseModal<T>('error', status, options)
  }

  // 反转
  toInversion (ctx: Koa.Context) {
    ctx.status = this.status
    ctx.body = {
      data: this.data,
      message: this.message,
      code: this.code
    }
  }
}
```



