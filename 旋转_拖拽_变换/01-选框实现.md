# 选框的实现

分析选框的功能特性：点击选框的**可选区域**，按下不放松，拖动鼠标，通过两个点确定最后选框的大小和位置，点击的初始点，鼠标拖动的最后停留点。当松开鼠标时，选框失效。

<image src="./images/selectBox.gif">

## 核心实现
- 指定一个元素，它所占据的位置（大小区域）表示**可选区域**，在它的内部插入一个元素**选中区域**的div元素（真正展示的选框）。

## 拖动
- onMouseDown：当鼠标按下时进行监听，onMouseMove和onMouseUp，记录当前的记录当前event的clientX，clientY，为startPoint。

- onMouseMove：鼠标按下之后，绑定了此方法，当鼠标开始移动时，触发方法，这个时候需要画矩形：当前触发的回调的event的clientX，clientY，作为endPoint，因为需要画的矩形是水平的，所有两个对焦点足够知道矩形怎么画：
  - left：min(startPoint.clientX, endPoint.clientX)
  - width: abs(startPoint.clientX - endPoint.clientX)
  - top: min(startPoint.clientY, endPoint....clientY)
  - height: abs(startPoint.clientY - endPoint.clientY)

  指定**选中区域**元素设置位置position（或者transform），并且指定该元素的大小width，height，指定元素的背景颜色使用户能看得间。

- onMouseUp：鼠标松开，清除所有**可选区域**的样式。


## 矩形相交
<image src="./images/boxesIntersect.gif">

判定当前的**选中区域**和你期望的组件有交集 => boxesIntersect
```typescript
function boxesIntersect(boxA: Box, boxB: Box) {
  return boxA.left <= boxB.right
  && boxB.left <= boxA.right
  && boxA.top <= boxB.bottom
  && boxB.top <= boxA.bottom;
}
```

## 需要注意的细节

- 边界问题，包含**选中区域**的**可选区域**是endPoint能够生效的点，如果实现是window绑定onMouseMove，那么需要做边界判断，如果是**可选区域**元素直接绑定onMouseMove就不需要。（我更倾向于第二种，但是第一种更适合抽离逻辑）
- 文字选择默认行为，点击并拖动鼠标的时候会触发浏览器的默认行为，文字选择，因此需要这个单独的副作用在**拖动的过程中**即onMouseMove 设置 document.body.style.userSelect = 'none'（也不一定需要是document.body，可以是**可选区域**元素）。


## ReactDragSelect 组件大致的样子
```typescript
ReactDragSelectProps {
  // 子元素
  children?: React.ReactNode;
  // 点击事件触发
  onMouseDown: (event: React.MouseEvent) => void;
  // 拖动事件
  onMouseMove: (event: MouseEvent) => void;
  // 放下事件
  onMouseUp: (event: MouseEvent) => void;
  containerProps?: Record<string, any>;
  // querySelectorString
  handle?: string;
}

class ReactDragSelect {
  // 核心的render方法
  render() {
    const { containerProps, children } = this.props
    return (
      <div {...containerProps}>
        {children}
        {/* 选中区域展示元素 */}
        <div className="selected-area" />
      </div>
    )
  }
}
```

## 总结和反思
选框的重点就是怎么画框和怎么判断元素重叠，不过这里的重叠判断的非常简单，只是单纯的适合矩形场景，而且还是在矩形没有任何旋转角度的场景

以当前的判断机制遇到以下情况就会失效：
<image src="./images/rotateBoxIntersect.gif">


解决办法：[碰撞检测-判断多边形是否相交](https://blog.csdn.net/StevenKyleLee/article/details/88075814)