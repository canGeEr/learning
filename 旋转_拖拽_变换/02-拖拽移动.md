# 拖拽移动

分析选框的功能特性：点击**可拖拽**元素，按下不放松，拖动鼠标，通过两个点确定最后选框的大小和位置，点击的初始点，鼠标拖动的最后停留点。当松开鼠标时，取消拖拽。

<image src="./images/Draggable.gif">

## 抽离重复逻辑 DraggableProvider
发现**拖拽**的实现依赖于onMouseDown、onMouseMove、onMouseUp三个方法的绑定：
- 为指定的点击触发元素绑定onMouseDown方法
- 在onMouseDown方法中，window绑定onMouseMove和onMouseUp（也可以额外绑定onMouseLeave方法）
- 在onMouseUp为window解绑onMouseMove和onMouseUp
- 同时为了防止组件在卸载的时候绑定在window上的onMouseMove和onMouseUp没有被清除，需要在componentWillUnmount生命周期前执行一次解绑


为了方便复用，抽离 DraggableProvider 组件如下：
[DraggableProvider](https://github.com/draggable-resizable-rotate/react-draggable-provider/blob/main/src/DraggableProvider/index.tsx)


## 实现拖拽组件 Draggable
- 基本的移动逻辑：确定点击的startPoint，确定移动的时候的endPoint。鼠标和矩形元素是相对移动的，鼠标移动了多少，那么矩形就该移动多少 即对于元素来讲
  - newLeft: startLeft + endPoint.clientX - startPoint.clientX
  - newTop: startTop + endPoint.clientY - startPoint.clientY

- 移动比例moveRatio：

``` typescript
let changeX = (endPoint.clientX - startPoint.clientX) * moveRatio;
let changeY = (endPoint.clientY - startPoint.clientY) * moveRatio;
```

- axis 移动方向限制，handle能够触发点击移动的元素，scale元素的缩放大小（位移是通过transform控制的，scale会影响到translate的真实位移大小），bounds边界限制

-  移动的最小单位Grid: [number, number]：只有当每次移动的距离x超过grid[0]或者y超过grid[1]，那么元素的位置才能发生对应方向的偏移
```typescript
function snapToGrid(grid: [number, number], pendingX: number, pendingY: number): [number, number] {
  const x = Math.round(pendingX / grid[0]) * grid[0];
  const y = Math.round(pendingY / grid[1]) * grid[1];
  return [x, y];
}
// 使用
if (props.grid) {
  // 根据grid获取 changX、changY
  [changeX, changeY] = this.snapToGrid(props.grid, changeX, changeY);
}
```