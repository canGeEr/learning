# 拖拽变换

> 拖拽变换有点特殊，因为并不是简单的点击元素就能进行拖拽变换了，而是需要点击选中到元素的**锚点**（<font color="red">左上角，上边，右上角，右边，右下角，下边，左下角</font>），无论是那个点被点击都将触发拖拽事件并改变元素的大小和位置。

分析拖拽变换的功能特性：点击元素的**锚点**，按下不放松，拖动鼠标，通过两个点确定最后选框的大小和位置，点击锚点所对应矩形的点，点击锚点相对的点（对角/对边）。当松开鼠标时，取消拖拽。

<image src="./images/Resizable.gif">


## 变换逻辑
- 创建8个元素**锚点**并定位到各自对应的位置，同时每个**锚点**被DraggableProvider包裹
- 监听每个锚点的onMouseDown、Move、Up事件，<font color="red">并传入对应的锚点所处的位置</font>


```typescript
interface Point {
  clientX: number;
  clientY: number;
}
```
假设mouseDown点击的位置为startPoint: Point, endPoint: Point为mouseMove时鼠标的位置


讨论拖拽某个点：
- 假设拖拽右下角：left、top不变，求newWidth，newHeight：
  newWidth = lastWidth + (endPoint.clientX - startPoint.clientX)
  newHieght = lastHeight + (endPoint.clientY - startPoint.clientY)
- 假设是xxxx点，同理依次讨论四个点

讨论拖拽某条边：
<image src="./images/lineResize.gif">
- 假设拖拽右边：left、top、height都不变，
 newWidth = lastWidth + (endPoint.clientX - startPoint.clientX)
- 假设是xxxx边，同理依次讨论四条边

## 带<font color="red">旋转角度</font>的变换
<image src="./images/rotateResize.gif">

旋转的矩形变换明显复杂多，拖动一个**锚点**暂称其为拖动点dragPoint，对角点固定fixPoint，拖动点和对焦点共同确定最后矩形的位置 => 

矩形的中心点：
```typescript
centerPoint = {
  clientX: (fixPoint.clientX + dragPoint.clientX) / 2,
  clientY: (fixPoint.clientY + dragPoint.clientY) / 2,
}
```
矩形的height、width：
```typescript
size = {
  width: 点 dragPoint 到 对角边之一的距离,
  height: 点 dragPoint 到 对角边的另外一边距离,
}
```

简单总结一下拖动矩形定点需要做哪些事情：
- 计算拖动前旋转矩形8个锚点的<font color="red">真实坐标</font>
- 点击锚点，监听拖动，确认拖动点dragPoint，fixPoint
- 拖动中，根据dragPoint，fixPoint，rotate，反推出矩形的最新位置left、top，最新的大小width，height

## 计算旋转矩形的坐标
<image src="./images/caculateRotate.gif">

矩形旋转rotate度可以理解为，矩形的每个点，绕中心点旋转rotate度：

（x1，y1）为要转的点p1，（x2,y2）为中心点p2，当前的旋转角度为ϕ，如果继续顺时针旋转角度为θ：
对p2来说，p1的点 => （x2 - x1, y2 - y1），旋转的话相当于是一个圆，两点之间的距离是不会变得因此可以转换成极坐标方程：

```typescript
x2 - x1 = R * cosϕ 
y2 - y1 = R * sinϕ

x′ = Rcos(θ+ϕ)
y′ = Rsin(θ+ϕ)

x′=Rcosθcosϕ − Rsinθsinϕ
y′=Rsinθcosϕ + Rcosθsinϕ

x′=(x2 - x1) * cosθ − (y2 - y1) * sinθ
y′=(x2 - x1) * sinθ + (y2 - y1) * cosθ

// 最后，需要换回原来的坐标系
X = (x2 - x1) * cosθ − (y2 - y1) * sinθ + x2
Y = (x2 - x1) * sinθ + (y2 - y1) * cosθ + y2
```

## 计算矩形的width，height
```typescript
interface RotateRect {
    left: Point;
    right: Point;
    bottom: Point;
    top: Point;
    topRight: Point;
    bottomRight: Point;
    bottomLeft: Point;
    topLeft: Point;
}
```
假设获取旋转之后的坐标对象为 rotateRect: RotateRect，拖动点dragPoint，固定点fixPoint：

中心点前面说了比较好计算，怎么求width和height成了关键 => 求点 dragPoint 到 固定点的两条边的距离

```typescript
// 直线方程表示
export interface LineEquation {
  A: number;
  B: number;
  C: number;
}
// A * x + B * y + C = 0

/**
 *
 * @param pointOne Point 第一个点坐标
 * @param pointTwo Point 第一个点坐标
 * @returns LineEquation 两点直线方程
 */
export function getLineEquation(pointOne: Point, pointTwo: Point): LineEquation {
  return {
    A: pointTwo.y - pointOne.y,
    B: pointOne.x - pointTwo.x,
    C: pointTwo.x * pointOne.y - pointOne.x * pointTwo.y,
  };
}

/**
 *
 * @param point Point
 * @param lineEquation LineEquation
 * @returns number 点到直线的距离
 */
export function getPointToLineDistance(point: Point, lineEquation: LineEquation): number {
  const denominator = Math.abs(lineEquation.A * point.x + lineEquation.B * point.y + lineEquation.C);
  const molecular = Math.sqrt(lineEquation.A ** 2 + lineEquation.B ** 2);
  return denominator / molecular;
}
```

## 总结
旋转变换上面只是介绍了拖动矩形的顶点的锚点，如果拖动四边需要考虑的情况又不一样了，拖动某条边时无法确定拖动的最终点dragPoint，需要计算两个直线的交点确定 dragPoint

另外要说的就是计算的有点复杂，其实可以直接用矩阵表示坐标来计算值：
[moveable](https://github.com/daybrush/moveable)

