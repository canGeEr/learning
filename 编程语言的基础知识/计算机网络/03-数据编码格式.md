# 03-字符编码格式

## 为什么对字符进行编码
大家都知道计算机只有0和1，人类根本无法理解：直接输入0、1xxx存储别人也不一定看得懂，因此需要使用计算机语言（0、1）和人类语言字符进行转换，**这种将0、1等等数据转换成字符集叫做编码**，**当然将字符集按照编码格式反向的翻译回0、1叫做解码**

## ASCII
美国的计算机学家，将英语的字符大小写、日常使用的符号进行编号，总共用了127个字符只需要7位二进制表示即可，因此一个字节完全足够，至此ASCII码都是以0开头的，后七位表示真实的数字
> 但是ASCII只能较好的表示英文、当其他国家的人使用的时候存在障碍，因此各国都做了自己的一套编码格式

## GB2312
GB全称GuoBiao国标，GBK全称GuoBiaoKuoZhan国标扩展。GB2313也成功完成了一个阶段的使命：

在继承兼容ASCII的情况下，使用两个字节表示中文字符，前8位单个字节仍然和ASCII相同，后8位一一映射日常生活的中文字符，收录了6763个汉字以及682个特殊符号

但是出现两个问题：
- 两个字节仍然不够表示全部的中文字符
- 映射的字符和ASCII有重复，例如：中文的数字2和英文的数字2，这也是为什么输入法会有“全角”和“半角”的区别，半角是ASCII的表示字符，全角自然是中文字符


## GBK 和 GB18030
BG2312仍然不够用，所以进行拓展，其实GBK已经能够正常的涵盖全部的汉字和常用的字符了，但是需要展示繁体字和少数名族语言，再次进行拓展到GB18030，因此其实GBK能够满足日常需求，而且GB18030是四个字节表示一个字符，非常占内存，再加上现在使用汉字的人越来越多，所以电脑里GBK还是会用得更多

## Unicode
每个国家都做一套字节的字符编码集很乱，是时候出现一个“终结者”了。Unicode是一种规范，具体的实现是utf-8、utf-16、utf-32等等，为啥？

Unicode要解决统一管理的问题就得对全世界的字符进行编码，数量是相当庞大的，那么必定需要更多更长的字节，甚至四个字节表示一个字符，这相对于ASCII的消耗的5被，非常恐怖。

因此Unicode完全编码，也相应的出现了不同的存储实现方式（变长存储），但Unicode本身也有规定使用4个字节存储。

### UTF-8
UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度

它的规则也简单：
- 对于单字节的符号：字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的
- 对于n字节的符号（n > 1）：第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码

### UTF-16、UTF-32
UTF-16采用两个或者四个字节存储，码元（最小的表示字符的单位），UTF-32采用四个字节存储，UFT-16和UTF-32都有大（Big endian）、小（Little endian）尾序之别

## Little endian 和 Big endian
以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。

第一个字节在前，就是"大头方式"（Big endian），第二个字节在前就是"小头方式"（Little endian）。

那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？

Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。

如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式

> 可以看出、其实文件的开头一般都会标明该文件的编码格式（通过特殊的编码符号表示）

## 图像的编码
留个坑位（图像的编码问题和字符编码不同，图像需要完成的任务是存储当前图片大小的全部像素点的颜色信息，RGB、RGBA、HUV等等格式）

## 总结+自己的思考

### 不同的编码方式有什么影响
- 编码范围不一致，表示的字符的多少
- 表示范围越大，需要的字节数越多，同一个字符的需要更多的内存空间存储，因此同样的内容的文件不同的编码方式文件大小不一样

### 计算机或者网络传输的是编码格式吗
计算机IOS七层模型，每一层都有每一层的协议，协议之间是水平的，并且对下是透明的，下层无需关系上层的具体数据内容，每一层只需要把上层递交的数据交上当前层需要携带的信息（头信息）封装，再往下层交付。因此传输的还是二进制，编码只是表象

### 计算机或者网络而言，数据都是二进制，关键在于如何读取这些二进制
在文件编码兼容的情况下，GB2312是对ASCII兼容的，因此可以对ASCII进行填充0转换成GB2312，但是不兼容的情况下无法转换，比如ASCII和Unicode（但是UFT-8可以兼容）

### 乱码一般发生在读
如果使用不兼容的两个字符集，从一个字符集转到另外一个字符集，就会发生乱码的现象。但是在写入的时候，编辑器会根据你的输入字符重新找目标编码去映射，相当于没有转换而是直接翻译