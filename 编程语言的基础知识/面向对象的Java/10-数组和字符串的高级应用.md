# 10 数组和字符串的高级应用

## 一、数组
数组看起来好像简单，但是其中的条条框框还是很多，甚至一些更难以察觉的细节，值得我们思考。

### **(1) 声明、初始化、赋值数组 => 静态数组**
声明数组是声明数组变量，也就是一条语句的左边
```java
int [] a = new int[3];
int [] b = null;
int [] c = {1, 2, 3};
int [] d = new int []{new Integer(1), 2, 3};
```
如上：
- 语句左边是数组声明，声明的结构是栈空间的内存分配，内存空间别名叫变量名
- 语句右边是，初始化
    - 初始化为：null。这意味着堆空间仍然没有分配空间，只是栈空间的内存变量的类型声明为 int [] 类型。
    - 初始化为：new int[3]。显式的申请堆空间一段连续的内存，数组的每个元素内存类型锁定为int 型，并初始化元素值为默认值 0 ，这意味这一旦 

      ```java
      a[0] = 1.1;
      ```
      发生编译错误
    - 初始化为：{1, 2, 3}。和上一条一样，但是多了一个赋值非0的过程，但是这个过程却只要声明的时候才能完成（这个这个语法糖的规定，你不需要琢磨为什么，只不过是编译器的是在实现上的约束）
    - 初始化为： new int []{1, 2, 3}。我们只是上一点的初始化是非常好用的，但是无法在非声明时赋值，因此来了这个语法糖。


PS：在定义数组引用变量类型时，最好先写数组类型：
int []、int [] [] 等，再加上变量名。

### **(2) 静态数组的静态方法**
- 遍历：

  ```java
  for(Type variable: arrayTarget) {//优点for循环语法糖，缺点无法获取index下标
    variable;//数组元素
  }
  ```
- 数组复制：    

  ```java
  System.arraycopy(c, 0, b, 0, 3);
  //resoure array、resoure start index、target array、target start index、copy element count
  ```

- 排序sort：

  ```java
  void Array.sort( Array )
  ```
- 二分法搜索binarySearch：

  ```java
  void Array.binarySearch( Array )//数组已经被排序
  ```
- 比较相等equals：

  ```java
  void Array.equals( Array, Array )//数组对比元素
  ```