# 修饰词

## 访问控制
> 注意什么叫做同一包内 (**看包路径**) ， 子类可以和父类不在同一包内，可见性是类可见还是实例可见?

### **DEFAULT** (默认 -> 不写)
(在非接口对象中， 不声明 权限修饰符 默认就是 public, 而接口成员变量默认 public static final ，方法是public)


### **PUBKIC** 公有 => 类 / 接口 / 变量 / 方法
1. public 对象 为主对象
2. public成员 可以被所有类访问
3. public 方法和成员 都会被其子类继承

### **PROTECTED** 保护 => 变量 / 方法 / 不能修饰类（内部类除外）
1. 接口及接口的成员变量和成员方法不能声明为 protected
2. 分两种情况:  
(1) **子类与基类在同一包中**：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；   
(2) **子类与基类不在同一包中**：那么在子类中，**子类实例**可以访问其**从基类继承而来的 protected 方法**，而不能访问基类实例的protected方法。 

>     值得注意的是第二条的第二点 , 只有子类实例才能访问，其性质是私有的，它希望包外的类（非子类）无妨访问到，但是由于即使不在同一包内，子类的main为public, 或者其它的public方法，可以被其它任何包所访问。因此应该避免，所以，只有子类实例才允许访问。更甚至即使是子类和孙子类在同一包内，但爷爷类不在同一包，只有**孙子的实例**才能对子类访问其protected
> (当然着只是我个人的猜测  这样使得其更加封闭)

### **PRIVATE** 私有 => 变量 / 方法
1. 私有有利于分装 其它类 无法直接访问数据和修改数据，可以暴露一些共有接口，以代替直接访问，安全性高，便于扩展和检查
2. 权限 仅限于 该类的实例对象对其进行访问 ( 这和子类无法继承父类**私有**成员)
3. 方法私有化 : 一些方法没有公用性,列如方法只是辅助某个共有方法而存在的，没有必要暴露

###  方法继承规则
1. 父类中声明为 public 的方法在子类中也必须为 public。
2. 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
3. 父类中声明为 private 的方法，不能够被继承。


### 一些规则总结
1. 既然是访问控制，一般是从安全性和封装性考虑
如： 
> (1) 限于谁可访问  (2) 可否继承 (3) 继承权限是否可以改变 (改变可能造成孙子类被屏蔽)


## 非访问控制

### **FINAL** => 对象 / 变量 / 方法
1. 对象不可继承
2. 分类final方法不能被重写
3. 变量值不改变
> final修饰对象时，只有对象的方法会自动final,而域不会，任然是可变的
### **STATIC** 静态(类域) => 变量 / 方法
1. 属于类
2. 静态变量， 静态常量 （+ final 有效的避免被修改的风眼）
3. 静态方法只能访问类域 ，无论是变量还是方法

### 等待更新