# 说明
> 首先，思考清楚当前数据是否需要树形的数据结构，而不是像 “评论”，用两个表来代替树形

树形结构即使设计出来，也需要考虑性能和是否能够解决问题：
- 问题一：获取某节点的所有子节点（包括孙子节点），拉取所有子节点数据，然后在内存拼接
- 问题二：获取某个节点的直属子节点
- 问题三：获取某个节点的父亲节点
- 问题四：删除、插入节点

假设存在树形结构如下：
```bush
1 food
  2 fruit
    3 red
      4 cherry
    5 yellow
      6 banana
  7 meat
    8 beef
    9 pork
```

## Adjacency List
> 每一条记录存parent_id，没有 parent_id 为 根节点

| id          | name        | parent_id   | 
| ----------- | ----------- | ----------- |
| 1           | food        |             |
| 2           | fruit       | 1           |
| 3           | red         | 2           |
| 4           | cherry      | 3           |
| 5           | yellow      | 2           |
| 6           | banana      | 5           |
| 7           | meat        | 1           |
| 8           | beef        | 7           |
| 9           | pork        | 7           |

**完成任务**：
- 解决**问题二**：根据节点id，查询parent_id === id
- 解决**问题一**：递归执行SQL，根据 每层的 id 找所有子节点 parent_id 为 id
- 解决**问题三**：通过parent_id查找
- 解决**问题四**：
  - 删除：只能一层一层的删除所有有关联的数据，当然如果你只是删除当前数据的话，数据表里就有冗余数据
  - 插入：最简单，写入parent_id 就行

**注意事项**：
- 优点：
  - 数据库层面简单实现
- 缺点：
  - 查询困难连带删除困难，虽然可以进行简易删除但是导致冗余数据
  - 查找数据需要递归执行sql，除非获取根目录所有子节点7

## Path Enumerations
> 每一条记录存path，没有 path 为 根节点

| id          | name        | path        | 
| ----------- | ----------- | ----------- |
| 1           | food        |             |
| 2           | fruit       | /1          |
| 3           | red         | /1/2        |
| 4           | cherry      | /1/2/3      |
| 5           | yellow      | /1/2        |
| 6           | banana      | /1/2/5      |
| 7           | meat        | /1          |
| 8           | beef        | /1/7        |
| 9           | pork        | /1/7        |

**完成任务**：
- 解决**问题二**：根据节点id和path，只需要查 子节点的 path = path + \`/${id}\`
- 解决**问题一**： 只需要在二的基础上，加上path的模糊匹配

- 解决**问题三**：把当前节点的path截取尾部的数字
- 解决**问题四**：
  - 删除：和查询所有子节点一样，直接模糊匹配删除所有子节点
  - 插入：最简单，写入 path 就行

**注意事项**：
- 优点：
  - 算是对 **Adjacency List**  的增强，弥补了 parent_id 需要层级递归查找所有的子节点
- 缺点：
  - path不够规范，和代码程序实现耦合高
  - path的长度有限，迟早会被占用完，所以也并不是无限层级


## Nested Sets
> 每一条记录存 nleft 和 nright，本质是想通过前序遍历把整个树的节点串联起来
  <img src="./../../IMAGES/1644838277078.jpg" alt="">
