# 02-路线匹配
```javascript
import {
  BrowserRouter as Router, // 或者 HashRouter as Router
  Switch,
  Route,
  Link,
} from 'react-router-dom';
```

## Router 
- 可以是 hash模式或者history模式，你可以根据你需要的兼容性选择对应的模式
- 一个  Router  属于一个单独的路由模块，所有的在组件内的其它 react-router组件 触发，
才能让 该Router模块响应功能，因此般将Router写在最外层，这样就可以随意编写路由代码，而没有心智负担



## Route
用于设置匹配路径**path**和对应的组件**component**，显示对应组件的逻辑，当Route指定的path和当前的location.path匹配到时，自动的触发组件的显示，不匹配时，卸载组件

但是它有一些特性：
1. **全匹配**：Route组件从上到下匹配，如果匹配到了就渲染，不管是不是相同，或者路径包含。如果需要选择只渲染一个，需要使用Switch组件进行包裹（其实就是Switch组件内部进行switch逻辑通过props.children的节点的path过滤其它节点
    ```javascript
    const DeepRouterCom = () = {
      return (
        <Router>
          <Route path="/about" component={About} />
          <Route path="/about" component={About} />
          <Route path="/" component={Index} />
        </Router>
      )
    }
    //这三个组件，当url为"/about"的时候同时显示
    ```

2. **非精准匹配**，比如Route的，假如path="/"和path="/about"同时存在，而且"/"的route组件在"about"组件之前，那么当url路径变化为"/about"是，会先匹配到path="/"的Route，如果这个时候还被Switch包裹，那么“about”组件是不会显示的，解决这个问题可以使用 exact 开启精准匹配
    ```javascript
    const DeepRouterCom = () = {
      return (
        <Router>
          <Switch>
            <Route path="/" component={Index} />
            <Route path="/about" component={About} />
            <Route path="/about" component={About} />
          </Switch>
        </Router>
      )
    }
    //这三个组件，当url为"/about"的 "about" 组件不会显示，只能渲染出Index
    ```

3. **透传**： Route通过component属性传入的组件，会被透传history、match、location、staticContext（ssr才有）

4. **renderProps**：透传children，或者使用render属性，传递一个函数，函数执行的结果是Route匹配渲染的结果
    ```javascript
    const DeepRouterCom = () = {
      return (
        <Route path="/">
          {
            ({history, match, location, staticContext}) => (
              <Home />  {/* 不传递进去，获取不到对应的路由订阅 */}
            )
          }
        </Route>      
      )
    }
    ```

5. 代码分块，注意子组件使用的Route需要使用绝对路径，[nesting](https://reactrouter.com/web/example/nesting)


## Link
Link作为导航的按钮单位，它应该具有所有编程式导航的所有功能：
- 去哪里 => to （base、hash、query）
- 到什么参数 => to.state
- 能不能使用自定义的标签（像Vue的label一样）

1. **导航行为**：
    ```javascript
    <Link to="/courses?sort=name" />

    <Link
      to={{
        pathname: "/courses",
        search: "?sort=name",
        hash: "#the-hash",
        state: { fromDashboard: true }
      }}
    />
    <Link to={location => ({ ...location, pathname: "/courses" })} />
    ```

2. **自定义UI**：
    ```javascript
    const FancyLink = React.forwardRef((props, ref) => (
      <a ref={ref} {...props}>💅 {props.children}</a>
    ))

    <Link to="/" component={FancyLink} />

    // 或者
    <Link to="/">
      <Component />
    </Link>
    ```

> NavLink是在Link基础上封装的，核心功能提供当该Link被target时，指定的类名和样式，甚至可以触发回调

## location和match
- match
  ```javascript
  {
    params: { // path/:id 传过来的参数
      [userDefined]: true
    }
    isExact: Boolean, // 当前的Route是否精准匹配
    path: string, // 当前被匹配的Route的 path ，可以基于这点实现嵌套路由
    url: string, // url匹配到当前Route的路径部分
  }
  ```


- location，几乎和Link的to属性对应，当前路由被切换过来的信息
  ```javascript
  {
    key: 'ac3df4', // not with HashHistory!
    pathname: '/somewhere',
    search: '?some=search-string', // 只有这里才能获取到url的search参数
    hash: '#howdy',
    state: { // to的state传过来的数据
      [userDefined]: true
    }
  }
  ```

## Redirect
Redirect不过是一个可以自动触发跳转的Link，和Link的核心用法相差不大


## Hooks
- useLocation
- useParams 直接的获取原来的match.params对象
- useHistory
- useRouteMatch 获取和原来的match对象一致，只不过里面可以传入参数，参数是一个Route匹配规则，如果能和当前url路径匹配成功，那么返回匹配的match，不能则为Null