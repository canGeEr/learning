# typescript的基本使用

## 关键词表示
在ECMAScript中，我们用基本数据类型对应的构造函数，比如数值类型Number，字符串类型String。
但是在语法中它已经是关键字了（或者说内置对象），我们需要采用全新的变量类型约束的标识符，又考虑到typescript“面向对象”的语法，参考
java，于是：

typescript使用string、number等等小写的”构造函数“标识符作为类型的关键字。
```typescript
let username: string = 'wczix'; // string类型变量
let age: number = 22; // age类型变量
```

列举一下：
- 常用：string、number、boolean、void（函数返回类型）、**object**（表示引用类型，不要和Object搞混淆）
- 不常用：null、undefined（null和undefined过于特殊）、any（它不够安全）、never、unknow
- 数组常用： number[]、boolean[]、类型+[]（什么类型的数组）

## 类型约束
> 类型约束后代码提示信息变多，对每个变量的类型或者引用变量的属性都能追踪到

一旦一个变量定义了类型之后，那么对这个变量的任何操作都会检查类型是否和操作匹配，比如：
- 赋值 检测两侧的变量的值和类型是否符合
- 传递参数 检测新参和实参是否类型一致
- 引用访问属性（或者方法） 判断引用是否存在改属性（引用类型需要提前声明是否具有该属性）
- 方法返回值 对方法进行扫描，确认是否返回对应的类型值

> 类型约束极大的强化了规范开发的安全性，减少了不必要的bug，而且更加语义化。



## 类型断言
有些变量一开始在声明的时候设置的可能是any和unknow类型，那么他们的具体类型不确定，但是这个时候又需要把该变量赋值给一个明确类型的变量，比如：
```typescript
let username: string = 'wczix';
let nickname: any = <string>'1';
// let nickname: any = '1' as string;
username  = nickname
```

类型断言非常有用，它不仅仅是语义化，而是让ts解析器明白这里没有错误。

## 复杂数据约束
对与数组、对象等类型，数据结构复杂多变，我们该如何进行约束?

对数组：元组
```typescript
let x: [string, number];
x = ['hello', 10]; // 声明类型和数组对应的下标的值类型必须符合
```

对于对象：接口
- 对象变量的类型声明，这个声明意味着约束该对象必须拥有对应属性名，对应的属性名必须拥有对应的类型值

    ```typescript
    // 
    let person: { username: string, age: number } = {
      username: 'wczix',
      age: 1
    }
    ```

- 但是有的时候，我不确定对象的值是否包含某个属性，这个时候就需要 ? 标识符表示属性的可选

    ```typescript
    let adult: { username: string, age: number, money?: boolean } = {
      username: 'wczix',
      age: 1
    }// 表示成人可能有钱，也可能没有
    ```
  
- 我们发现这样还不行，每次需要什么属性都要往上面加，有没有可以允许动态数量的属性，但是对属性又存在一些规则？  **字符串索引签名**

    ```typescript
    let male = ...; //假设不清楚male有什么属性
    let adult: { username: string, age: number, money?: boolean, [proName: string]: any } = {
      username: 'wczix',
      age: 1,
      ... male //这里却需要全部展开
    }
    ```
    需要注意的是，这样的类型声明并不安全，因为当访问adult的属性时候，编译器无法确实该属性是否在上面！


- 我们发现这样写实在是麻烦，每次写都要类型都要一大串，这个时候 **type** 出场了

    ```typescript
    type human = { username: string, age: number, money?: boolean, [proName: string]: any }; //注意这个等号
    let person: human;
    let adult: human;
    ```

> 数组其实也是特殊的对象，对类型的约束对数组也是有效的



## 对于对象属性的约束
- 字面量类型的直接约束、包括别名（上一段已经展示了）
- class 实例的成员和方法的约束
- 接口 对 实例 或者 字面量 类型的约束

## 复杂情景
- 函数新参类型声明，并且需要默认值
- 对象的解构
- 类型的与/或运算


第一点：
```typescript
function add({ first, second }: { first: number, second: number } = { first: 2, second: 2 }) : number {
  return first + second;
}
```

第二点：
```typescript
const { first, second }: { first: number, second: number } = { first: 2, second: 2 }
```

第三点：
```typescript
// 在一些特殊情况下，类型一次性无法完全声明，因为你不知道它到底有什么
// 声明了，但没有完全声明

// & 与运算
type FirstNumberObj   = { first:  number };
type SecondNumberObj  = { second: number };

const { first, second }: (FirstNumberObj & SecondNumberObj) = { first: 2, second: 2 }


// | 或运算
const obj: (FirstNumberObj | SecondNumberObj) = { first: 2}
```