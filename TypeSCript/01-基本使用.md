# typescript的基本使用

## 关键词表示
在ECMAScript中，我们用基本数据类型对应的构造函数，比如数值类型Number，字符串类型String。
但是在语法中它已经是关键字了（或者说内置对象），我们需要采用全新的变量类型约束的标识符，又考虑到typescript“面向对象”的语法，参考
java，于是：

typescript使用string、number等等小写的”构造函数“标识符作为类型的关键字。
```typescript
let username: string = 'wczix'; // string类型变量
let age: number = 22; // age类型变量
```

列举一下：
- 常用：string、number、boolean、void（函数返回类型）、**object**（表示引用类型，不要和Object搞混淆）
- 不常用：null、undefined（null和undefined过于特殊）、any（它不够安全）、never、unknow
- 数组常用： number[]、boolean[]、类型+[]（什么类型的数组）

## 类型约束
> 类型约束后代码提示信息变多，对每个变量的类型或者引用变量的属性都能追踪到

一旦一个变量定义了类型之后，那么对这个变量的任何操作都会检查类型是否和操作匹配，比如：
- 赋值 检测两侧的变量的值和类型是否符合
- 传递参数 检测新参和实参是否类型一致
- 引用访问属性（或者方法） 判断引用是否存在改属性（引用类型需要提前声明是否具有该属性）
- 方法返回值 对方法进行扫描，确认是否返回对应的类型值

> 类型约束极大的强化了规范开发的安全性，减少了不必要的bug，而且更加语义化。



## 类型断言
有些变量一开始在声明的时候设置的可能是any和unknow类型，那么他们的具体类型不确定，但是这个时候又需要把该变量赋值给一个明确类型的变量，比如：
```typescript
let username: string = 'wczix';
let nickname: any = <string>'1';
// let nickname: any = '1' as string;
username  = nickname
```

类型断言非常有用，它不仅仅是语义化，而是让ts解析器明白这里没有错误。


## 对象字面量类型
对象字面量类型有两种
一种：{[property]: type, [property]: type}
```typescript
let persoon: {username: string, age: number};
```
另外一种：{[property]: type; [property]: type}
```typescript
let persoon: {username: string; age: number};
```
> 为了区分普通的对象，我们推荐使用第二种，属性之间使用分号分隔

## 数据约束示例
对与数组、对象等类型，数据结构复杂多变，我们该如何进行约束?

对数组：元组
```typescript
let x: [string, number];
x = ['hello', 10]; // 声明类型和数组对应的下标的值类型必须符合
```

对于对象：接口
- 对象变量的类型声明，这个声明意味着约束该对象必须拥有对应属性名，对应的属性名必须拥有对应的类型值

    ```typescript
    // 
    let person: { username: string; age: number } = {
      username: 'wczix',
      age: 1
    }
    ```

- 但是有的时候，我不确定对象的值是否包含某个属性，这个时候就需要 ? 标识符表示属性的可选

    ```typescript
    let adult: { username: string; age: number; money?: boolean } = {
      username: 'wczix',
      age: 1
    }// 表示成人可能有钱，也可能没有
    ```
  
- 我们发现这样还不行，每次需要什么属性都要往上面加，有没有可以允许动态数量的属性，但是对属性又存在一些规则？  **字符串索引签名**

    ```typescript
    let male = ...; //假设不清楚male有什么属性
    let adult: { username: string; age: number; money?: boolean; [proName: string]: any } = {
      username: 'wczix',
      age: 1,
      ... male //这里却需要全部展开
    }
    ```
    需要注意的是，这样的类型声明并不安全，因为当访问adult的属性时候，编译器无法确实该属性是否在上面！


- 我们发现这样写实在是麻烦，每次写都要类型都要一大串，这个时候 **type** 出场了

    ```typescript
    type human = { username: string; age: number; money?: boolean; [proName: string]: any }; //注意这个等号
    let person: human;
    let adult: human;
    ```

> 数组其实也是特殊的对象，对类型的约束对数组也是有效的；type 关键字是对 类型起别名



## 类型推断
ts要实时的检测我们的代码，**推断**出我们代码中变量的具体类型，那么我们每更改一次代码就要检测一次代码（毕竟不是每个程序员写的代码都是严格的声明类型，纠错策略）

特别是在一些不声明类型直接赋值的场景：
```typescript
let d = 1;
let g: typeof d;
g = '1'; // 报错：Type 'string' is not assignable to type 'number'
```
这里显然的，ts编译器推断出了变量g的类型为number。这段代码真的只是这么简单吗？

> 未明确指出变量类型的变量，它的类型确定于当前访问的代码行之前的所有代码一起的对改变量的**综合推断**

注意：typeof虽然在转换js之后可能无实际作用，但是在TS中，可以对任意变量使用typeof获取其类型，进而作为其它变量的类型使用！
```typescript
let persoon = {
  name: 'name',
  age: 1
}
let shepij: typeof persoon = {
  name: 'sehpij',
  age: 2,
  height: 172
}// 报错：Type '{ name: string; age: number; height: number; }' is not assignable to type '{ name: string; age: number; }'

// 说明推断 persoon 变量的类型是 { name: string; age: number; }
```