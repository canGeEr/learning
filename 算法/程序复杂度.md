# 01-程序复杂度

## 为什么需要

一个程序我们如果需要测试它的性能，两个指标：

- 运行完代码需要花费多长时间（时间复杂度）
- 运行代码需要的最大程序空间（空间复杂度）

但是如果一个程序，测试人员手动的去测试，需要大量的数据，而且不同的电脑不用的性能，相当的麻烦。因此，我们急需一个统一的标准，直接的分析代码就能大致的估计算法的性能。

## 怎么算

## 时间复杂度

假色，计算机执行一条某种语言的代码，需要的时间是 unitTime，那么一个程序执行多少条代码，就需要花费多长的时间：

```javascript
let varient = 1; // 这里花了 1 unitTime
for(let i=0; i<10; i++>) {//初始化 1 unitTime
  console.log(i); //循环 2 * 10 unitTime
}
```

但是大部分情况下，我们都是需要外部指定循环次数：

```javascript
function jiuZhe(n) {
  let varient = 1; // 这里花了 1 unitTime
  for(let i=0; i<n; i++>) {//初始化 1 unitTime
    console.log(i); //循环 2 * n unitTime
  }
}
```

这又如何计算呢？
因为当 n 可以随意值，我们直接拿 n 当计量单位，循环执行了 2\*n 次
（时间复杂度 O(n)）

## n => 无穷，留最高次

假色一个算法或者说函数时 2n 级别的，另外一个是 3\*n 级别的，当 n 趋于无穷大的时间，limit2n === limit3n，因此，再考虑算法的复杂度上，我们只留最高次幂项：

```javascript
for(let i=0; i<n; i++>) {//初始化 1 unitTime
  for(let j=0; j<n; j++>) {//初始化 1 unitTime
    console.log(i, j); //循环 2 * n unitTime
  }
}
```

O(n^2) 时间复杂度

## log(n) 对数阶

一个算法尤为经典：二分法，假设一个长度为 N 的数组，二分法查找，每次找都对半分，一直找到 1 为止。这个表达式刚好为以 2 为底 log(n)。之所以直接 log(n) 是有可能有三分法等等，我们只看最高幂次，因此直接省略以 2 为底，直接 log(n)

## 空间复杂度

一般都是递归函数，没调用一次递归，那么复杂度加一，一般都是以 O(n)级别，最经典的就是斐波那契数列：

```javascript
function feiBo(n) {
  if (n <= 1) {
    return 1;
  }
  return feiBo(n - 1) * n;
}
```

空间复杂度： O(n)

递归的二分法也是尤其经典：
没次将 n 分为两段计算，因此需要的空间就是 O(log(n))
