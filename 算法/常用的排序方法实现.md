## 二分法查找
```javascript
//left right 指针
function binarySearch(arr, target) {
    let left = 0
    let right = arr.length-1
    let middle = null
    while(left<=right) {
        middle = Math.floor((left+right)/2)
        console.log(middle)//3, 4, 5
        if(arr[middle] > target) {
            right = middle - 1
        }else if(arr[middle] < target){
            left  = middle + 1
        }else {
            //如果需要查找全部，从该index开始，左右开始查询
            return middle
        }
    }
    return -1
}

//递归查询
function binarySearch(arr, falg, left, right) {
    if(left <= right) {
        let middle = Math.floor((left+right)/2)
        if(arr[middle] === falg) return middle
        else if(arr[middle] > falg) {
            return binarySearch(arr, falg, left, middle - 1)
        }else {
            return binarySearch(arr, falg, middle + 1, right)
        }
    }
    return -1
}
```

## 冒泡排序
```javascript
function bubbleSort(arr) {
    let length = arr.length
    let temp = null
    let i = length-1
    while(i) {//多少趟
        for(let j=0; j<i; j++) {
            if(arr[j] > arr[j+1]) {
                temp = arr[j]
                arr[j] = arr[j+1]
                arr[j+1] = temp
            }
        }
        i--
    }
    return arr
}
```


## 选择排序
```javascript
//第一种 生成原数组
function selectionSort(arr) {
    let len = arr.length
    let i = len-1
    let minIndex = null
    let temp = null
    while(i) {
        minIndex = 0
        for(let j=0; j<=i; j++) {
            if(arr[minIndex] > arr[j]) {
                minIndex = j
            }
        }
        temp = arr[i]
        arr[i] = arr[minIndex]
        arr[minIndex] = temp
        i--
    }
    return arr
}
```

## 快速排序
```javascript
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    //中间位置
    let middle = Math.floor(arr.length / 2);
    let flag = arr.splice(middle, 1)[0]; //取出中间元素
    let left = [],
        right = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] < flag) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).cocat([flag], quickSort(right));
}


//第二种 在原数组上改变
function sortQuick(arr, lft, rit) {
    if(rit <= lft) return
    let middle = arr[lft]
    let left = lft
    let right = rit
    while(left<right) {
        while(left<right && arr[right] > middle) {
            right--
        }
        if(left<right) {
            arr[left] =  arr[right]
            left++
        }
        while(left<right) {
            left++
        }
        if(left<right && arr[left] >= middle) {
            arr[right] =  arr[left]
            right--
        }
    }
    arr[left] = middle
    console.log(lft, left-1, left+1, rit)
    sortQuick(arr, lft, left-1)
    sortQuick(arr, left+1, rit)
}
```

## 归并排序
```javascript
//使用递归，核心就是将数组一直二分下去
function mergeOrderArr(arr, left, right) {
    if(left >= right) return
    let arr3 = new Array(right-left+1)
    let middle = Math.floor((left + right)/2)
    mergeOrderArr(arr, left, middle)
    mergeOrderArr(arr, middle+1, right)
    let arr1Index, arr2Index, arr3Index
    arr1Index = left
    arr2Index = middle+1
    arr3Index = 0
    while(arr1Index<=middle && arr2Index<=right) {
       arr3[arr3Index++] = arr[arr1Index] < arr[arr2Index] ? arr[arr1Index++] : arr[arr2Index++]
    }
    while(arr1Index<=middle) {
        arr3[arr3Index++] = arr[arr1Index++]
    }
    while(arr2Index<=right) {
        arr3[arr3Index++] = arr[arr2Index++]
    }
    for(let i=0, len=right-left+1; i<len; i++) {
        arr[left+i] = arr3[i]
    }
}
let arr = [
    5, 7, 6, 3, 2, 56, 6, 2, 7, -3, 4, 5, 100, 101
]
mergeOrderArr(arr, 0, arr.length-1)
console.log(arr)
```