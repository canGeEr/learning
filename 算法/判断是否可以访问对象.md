# 关于访问对象的操作

## 可访问性
```javascript
//根据一段访问字符串，判断是否可以访问
//判断一段字符是否可以访问属性 a.b.c.d
const canVisit = (function() {
    function canGet(data, proArr, initial) {
        let target = data
        for(let pro of proArr) {
            if(pro in target) target = target[pro]
            else return initial
        }
        return target
    }

    return function canVisit(target, visitStr, initial) {
        const proArr = visitStr.split('.')
        return canGet(target, proArr, initial)
    }
})()
/*
//测试用例
const obj = {
    a: {
        b: {
            c: [{d:1}, {e:2}, {f: {k: 3, p: 7}}]
        }
    },
    v: ''
}

console.log(canVisit(obj, 'a.b.c.3.d.2', '找不到'))
*/
```

可选链操作符( ?. )配合数组的reduce方法，实现递归读取，但是没有判断是否属性存在
```javascript
  function canGet(data, proArr, initial) {
      // let 
      const result = proArr.reduce(function(target, pro) {
        return target?.[pro]
      }, data)
      return result
  }
```


## 根据包名，在指定空间中创建对象
```javascript
function namespaceToCreateObject(oNamespace, sPackage) {
    if(sPackage.length === 0) return
    let packArr = sPackage.split('.')
    if(oNamespace.hasOwnProperty(packArr[0]) &&  oNamespace[packArr[0]] instanceof Object) {
        namespaceToCreateObject(oNamespace[packArr[0]], packArr.slice(1).join('.'))
    }else {
        namespaceToCreateObject(oNamespace[packArr[0]] = {}, packArr.slice(1).join('.'))
    }
    return oNamespace
}
/*
//测试用例
console.log(namespaceToCreateObject({a: {test: 1, b: 2}}, 'a.b.c.d'))
*/
```
