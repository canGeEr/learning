# 11-内存泄漏

JS 一样分堆内存和栈内存、函数内的局部非引用变量类型分配的空间在栈内存，当函数执行完，函数执行栈弹出、对应的在该函数执行栈分配的内存
也被重新收回、但是引用类型由于结构复杂、数据长度不固定、纯粹在堆内存中

## 标记清理法

- 标记所有申明的内存变量
- 把环境栈变量和被栈变量引用能够访问到的变量的标记都清除
- 剩下的就算无法访问到的内存变量，垃圾回收

## 引用计数

如果一个变量的值为引用值（即堆内存的地址），那么这个块内存的引用数加 1，如果该变量被其它值覆盖，那么块内存的引用数减一、垃圾回收器下次运行时，清理引用数为 0 的内存

> 问题：

- 循环引用
- CSSOM 和 BOM 如果存在被引用、即使被移除页面（isConnected 为 false）也依旧存在于内存中

## 改善

- 全局作用域的声明的变量无法回收，只要页面存在，那么声明的变量就一直存在
- 减少定时器的创建
- 少用闭包、闭包会打包引用父级作用域的变量
- 不要循环引用、特别时 DOM 和 CSSOM、减少对 DOM 的事件绑定（引用计数，当 DOM 移除页面，绑定函数对象存在应用，DOM 对象内存不会销毁）
- const、let 优化
- 减少删除属性、减少"意外"的添加属性（隐藏类）
- 静态分配、数组长度一次性足够大
- 重复利用对象，非必要时不要创建大量对象、特别时函数类，功能一致不要放在循环里面
