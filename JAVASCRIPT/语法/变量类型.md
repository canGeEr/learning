# 数据类型

## 数据类型的分类

### Primitive 原始数据类型
- 空值（表示未定义的值，但是null会被typeof判断为对象属于系统的bug，地址000开头的表示对象，但是空值为 000000xx 全零
  - null（意料之内的空值）
  - undefined（表示未赋值）

- 基础类型
  - string：非常多的接口，String上的各种操作字符串的函数，作为数组或者可迭代对象的各种函数，正则匹配的各种数组（KMP算法）
  - number：浮点类型、NaN、-+ / Infinity
  - boolean

- Symbol
  - 使用场景：作为对象的键，不重复的属性名、消除开发自定义的不安全字符串常量、各种内置符号
  - 用法：
    - Symbol() 传入字符串，非字符串被转换为字符串，生成独一无二的值
    - 

### 对象类型（引用）Object
## 分类
- 原始类型（primitive）
    - null、undefined、symbol （和其它类型排斥）
    - boolean、string （和number类型转换）
    - number
- 引用类型
    - object、function、array
    - 内置：Date、RegExp
    - 环境：DOM和BOM

## 判断类型
主要使用四个方面：
- typeof
- instanceof
- toString
- 能力检测（比如数组的一些特有方法）
- 标准的检测方法（比如Array.isArray()）

### typeof
> 无法细分引用类型

- typeof对原始类型除了null是个bug，其它的都正常
- typeof对引用类型检测都是object，但是function对象为function

判断是否为引用类型：
```javascript
variate !== null && (typeof variate === 'object' || typeof variate === 'function' )
```


### instanceof
> instanceof默认会调用[Symbol.hasInstance]方法

原理：检测对象的原型链上是否匹配到构造函数的显示原型
```javascript
{
    instanceof: function instanceof(obj, constructor) {
        let proto = obj.__proto__
        let prototype = constructor.prototype
        while(proto) {
            if(proto === prototype) return true
            proto = proto.__proto__
        }
        return false
    }
}
```
> 原型可以被修改（setPropertyOf、\_\_proto\_\_），instanceof不安全

### toString
```javascript
function classOf(variate) {
    return Object.prototype.toString.call(variate).slice(8, -1)
}
```

## 类型转换

### null、undefined
- 布尔 null、undefined => false
- 字符串 null => 'null'；undefined => 'undefined'
- 数字 null => 0；undefined => NaN

### 字符串 => 数字
普通的Number函数直接转换没有啥好讨论的，看起来像数字的字符串都可以转换为数字，不行的话转换为NaN

但是有两个函数：
parseInt、parseFloat，他们的解析规则有点复杂：      
从位置0开始查看每个字符，**直到找到第一个非有效的字符为止**，然后把该字符之前的字符串转换成数字。不过，对于这个方法来说，**第一个出现的小数点是有效字符**。如果有两个小数点，第二个小数点将被看作无效的

### 对象 => 原始类型
> 默认调用[Symbol.toPrimitive]方法

如果Symbol.toPrimitive函数返回的不是原始值，那么根据运算符的需要，调用valueOf或者toSting方法直到获取原始值

### 相等判断
> == 和 === 的区别在于类型判断，再进行值比较
- undefined == null //true
- 字符串和boolean都会优先转换为数字比较
    ```javascript
    '0' == false
    ```


## 进制转换
默认是10进制转换，因此没有感知
- parseInt(variate, radix) 解析一个字符串并返回指定基数的十进制整数， radix 是2-36之间的整数，表示被解析字符串的基数
    - 36 >= radix >= 2 ，不然返回NaN 
    - 第一个非空格字符不能转换为数字，不然返回NaN 
- toString(variate, radix) 将variate看出10进制的数，转换为radix为基数的数

他们的功能刚好相反：        
parseInt识别variate以radix为基，转换为10进制        
toString识别variate以10为基，转换为radix进制   

```javascript
let variate = '34'
variate = parseInt(variate, 5)
variate = variate.toString(5)
//'34'
```


## 为什么0.1 + 0.2 === 0.3为false