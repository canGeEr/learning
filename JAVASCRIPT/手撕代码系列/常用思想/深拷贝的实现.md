## 深拷贝

深拷贝的就是在拷贝的时候，需要将当前要拷贝的对象内的所有引用类型的属性进行完整的拷贝，也就是说拷贝出来的对象和原对象之间没有任何数据是共享的，所有的东西都是自己独占的一份

> 没有对 Date 数据类型，正则类型进行处理 [具体的数据类型处理](https://www.w3cschool.cn/article/8b3a1e469cd340.html)

```javascript
// W3C的实现
const deepClone = (function () {
  let objMap = new Map(); // 也可以是二维数组

  function __deepClone(variate) {
    if (!isObject(variate)) return variate;
    if(objMap.has(variate)) return objMap.get(variate);
    const PrototypeClass = classOf(variate);
    let newObj = null;
    switch (PrototypeClass) {
      case Date:
        newObj = new Date(variate.getTime());
        break;
      case RegExp:
        newObj = new RegExp(variate.source, variate.flags);
        break;
      case Function:
        newObj = cloneFunction(variate) || variate;
        break;
      default:
        newObj = new PrototypeClass();
    }
    objMap.set(variate, newObj);
    Reflect.ownKeys(variate).forEach((prototype) => {
      newObj[prototype] = __deepClone(variate[prototype]);
    });
    return newObj;
  }

  // 克隆函数
  function cloneFunction(func) {
    const funcRegExp =
      /\((?<arguments>[\s|\S]*)\)[\s|\S]*\{(?<funBody>[\s|\S]*)\}/;
    const funcString = func.toString();
    if (func.prototype) {
      const result = funcRegExp.exec(funcString);
      if (result) {
        const [funcComponentString, argumentsString, funcBodyString] = result;
        const argumentsArr = argumentsString.replaceAll(" ", "").split(",");
        return new Function(...argumentsArr, funcBodyString);
      } else {
        return null;
      }
    } else {
      return eval(funcString);
    }
  }

  // 如何判断一个对象是否是变量
  function isObject(variate) {
    return (
      variate !== null &&
      (typeof variate === "object" || typeof variate === "function")
    );
  }

  function isArray(variate) {
    if (Array.isArray) {
      return Array.isArray(variate);
    }
    return Object.prototype.toString.call(variate).slice(8, -1) === "array";
  }

  function classOf(variate) {
    if(!isObjet(variate)) null
    return Object.getPrototypeOf(root).constructor || window[String.prototype.toString.call(variate).slice(8, -1)]
  }

  return function exposeFun(variate, { isDeep = false, canJson = true }) {
    if (!isDeep) return Object.assign({}, variate);
    try {
      if (canJson) return JSON.parse(JSON.stringify(variate));
    } catch (e) {
      console.warn(e, "该对象无法json化，使用深拷贝兜底");
    }
    objMap = new Map();
    return __deepClone(variate);
  };
})();

var resource = {
  a: 1,
  b: 1,
  date: new Date(),
  function: function fuck(a, b, ...c) {
    console.log(this.function);
  },
};

const clone = deepClone(resource, { canJson: false, isDeep: true });
```

## 判断两个对象是否相互引用

```javascript
const canVisited = function (variate, otherVariate) {
  let objMap = null;

  function __canVisited(variate, otherVariate) {
    if (!isObject(variate)) return false;
    if (objMap.has(variate)) return false;
    if (variate === otherVariate) return true;
    objMap.set(variate, true);
    const flag = Reflect.ownKeys(variate).some((prototype) => {
      const flag = __canVisited(variate[prototype], otherVariate);
      return flag;
    });
    return flag;
  }

  function isObject(variate) {
    return (
      variate !== null &&
      (typeof variate === "object" || typeof variate === "function")
    );
  }

  return function exposeFun(variate, otherVariate) {
    objMap = new Map();
    return __canVisited(variate, otherVariate);
  };
};

const isLoopUsed = function (first, second) {
  const result1 = canVisited(first, second);
  const result2 = canVisited(second, first);
  return result1 && result2;
};

const node1 = {
  name: "node1",
  next: null,
};

const node2 = {
  name: "node2",
  next: null,
};

const node3 = {
  name: "node3",
  next: null,
};

node1.next = node2;
node2.next = node3;
node3.next = node1;

console.log(
  isLoopUsed(node1, node2),
  isLoopUsed(node1, node3),
  isLoopUsed(node3, node2)
);
```
