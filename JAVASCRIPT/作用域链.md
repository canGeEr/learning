# 作用域链
其实好多人在解释作用域链都喜欢和执行环境，环境上下文，环境栈联系在一起，但我觉得他们应该却别对待，甚至由于某些原因，
我认为他们在根本上存在这差距。因此我特意的将这作用域这节分开，那接下来就开始讨论一下，JS神奇的作用域

## 变量标识符
如果你有了解一下底层的语言，那你就能知道变量其实在编译的时候，系统为其分配一个栈空间内存，最后将变量全部替换成内存地址，在执行中获取变量的值就是
根据改地址寻找内存，内存的数据就是所谓的赋值（关联）的值。如果时引用类型呢？先创建栈内存，在堆内存，将堆内存的起始地址给栈内存单元存储，因此引用
变量类型的栈内存地址存储的是一个地址（注意那解释器怎么判断存的数据是什么呢？ 如果你学过汇编你就知道，汇编会根据寻址方式的不同，来查找内存）。

## 作用域
那要了解作用域链不然先了解一下作用域，什么是作用域呢？
1. 变量（或者说标识）的作用域是程序源代码中定义这个作用域的区域
2. 作用域是描述这个变量起作用的代码范围

## JS高级程序设计对其解释
*当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所 在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对 象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中 的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。*

## JS权威指南
这里就不粘贴了，大致描述的是，在定义函数的时候，函数就绑定了一个作用域，这个作用域就是在定义该函数的环境的作用域链    
举个简单的例子
```javascript
function A() {
  function innerA() {

  }
}
A()
//注意在定义A是，是通过调用A函数，形成了一个环境是A执行上下文环境，该环境的所保存的作用域，就是A在定义是保存的作用域。
```
## 作用域 和 作用域链 分析
注意JS采用静态词法分析（大部分语言都是这样）
```javascript
function b() {
  console.log(variable)
}
var variable = 'global'
function a() {
  var variable = 'defined in a'
  b() //b执行
}
//打印出global我们要注意，函数是定义在哪里的，全局环境，所以它的作用域链包括全局作用域。
```
**那么其实可以得出一个结论：作用域是在函数一旦定义的时候就确定的，而不是在执行的时候。**

```javascript
function b() {
  console.log(variable)
}
var variable = 'global'
function a() {
  var variable = 'defined in a'
  b() //b执行
  function firstA() {
    var variable = 'defined in firstA'
    console.log(variable)
  }
}
//根据以上代码很好理解作用域链，一个变量定义在一个函数，那么在该函数及其內部定义的函数（递归一样，因此有个先后顺序，如果把这种顺序表现成一个数组或者链的话更加容易理解）对该变量都是有权可以访问的。
```
**得出两个结论：**    
1. **作用域链是作用域的集合，一个带有属性名和属性值的对象被抽象的表示为作用域，如果访问变量则查找对象属性    
确定是否含有，未找到则沿其作用域链的下一个继续查找，直到结束。否则报错未找到。**

2. **作用域链是在函数定义时确定，一旦函数定义，那么作用域链其实已经确定（那就是定义该函数的函数的作用域链，在全局定义，上层函数自然是全局函数）   
当函数执行的时候，再将自身的作用域添加到该作用域链的最前端。**

> 提前先所说一下，其实作用域和所谓的执行上下文对象都是包含定义变量名为属性名，对应值为属性值的一个对象，他们的存在都是为了使得函数内使用的变量能够正确的查找并访问，这和一种说法：*既然都有作用域这个对象了，还存在于堆，那为什么需要栈去存储基本类型元素呢*其实并不冲突。


## 闭包和作用域链的共存依赖的关系
我们先来看一些东西，了解一下栈内存和堆内存的基本区别
```javascript
//注意我们是要搞明白堆和栈到底发生了什么事情

//index1.js
function A() {
  var variable = 'a'
  var obj = {variable: 'a'}
  return variable
}
A()   //注意要调用
//调用函数后，在栈里分区，多了一个A函数栈，该分区栈存储声明的栈变量的值，一个是variable
//一个是obj （它存储的是一个指向堆内存对象的地址）如果你明白了这一点，那么你的指针其实学的差不多了。但是函数结束呢？
//栈内存的变量一个个销毁，并和堆内存对象失去关联，直至A函数栈退出栈空间，并返回一份变量variable的内存值的复制值。
//那堆呢？对象obj这个时候自然由垃圾回收机制处理，注意不是立刻就销毁。

//index2.js
function A() {
  var variable = 'a'
  var obj = {variable: 'a'}
  return obj
}
var obj = A()
//但是这里返回了obj对象，堆内存关联obj的对象的地址被obj变量存储，关联，因此堆内存的该对象无法被垃圾回收器自动处理
//释放：obj  = null 接触关联
```
> 函数不仅保存着函数本身的信息，还引用着作用域链，注意是**函数引用着作用域链**
基于上面的东西，我们开始讨论闭包。

> 很多人可能会说，在chrome调试的时候表现的不是这样的，比如说scope里是否存在clourse来判别是否包含闭包，就和看[[Scopes]]以为其是作用域一般，事实上
并非如此

在《你所不知道的JavaScript》中有说到对闭包的定义
*当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使**函数是在当前词法作用域之外执行***

```javascript
//摘自《你所不知道的JavaScript》

//例子1  
function foo() {     
  var a = 2; 
  function baz() {  console.log( a ); // 2 } 
  bar( baz ); 
} 
 
function bar(fn) {  fn(); // 妈妈快看呀，这就是闭包！ }

//例子2
function foo() {     
  var a = 2; 
  function bar() {  console.log( a );  } 
  return bar; 
} 
var baz = foo();
```

### 为什么说闭包和作用域链有关
1. 首先闭包的之所以叫闭包，就是能查找到函数自身的作用域，一级一级往上找。      
2. 另一个难理解的地方在于返回函数，或者函数的引用，调用函数时仍然能够访问函数栈的变量。    
3. 其实关键的是要明白，函数栈中确实存在着当前函数执行声明的变量的值，但是由于执行上下文的原因，和规则的处理变量的访问权限，执行上下文的变量对象和
作用域，作用域链等都是存在于堆内存的，相当于赋值了一遍堆内存的值。这样看似重复多余，但是执行上下文和作用域确实是实习变量的正确访问比不可少的，显然
如果只是分区域的函数栈是无法完成这一功能的。
4. 因此，在返回函数时，虽然函数栈的变量都释放了，但是函数的函数作用域的引用仍然存在，作用域又相当于栈变量的一份复制，所以看似以为内存没有释放是由于函数环境一直存在，但函数栈早已经退出，只不过函数作用域没有被垃圾回收器清除而已（该函数关联着作用域）。


## 总结
如果按照这样分析的话，你依然能够明白，其实函数作用域应该和变量对象或者说活动对象（请不懂的自行百度）挂钩 --> 作用域链存储的是变量对象的指针列表。
但是执行环境太大，包括了变量对象。