# JavaScript 数据类型

## 一、基本数据类型
1. Undefined  
2. Null  => Object 空对象 表示空指针
3. Boolean    
4. Number    
5. String  
6. Object 细分
	- Function
	- Array
	- RegExp
	- Object

## 二、typeof 操作符
> typeof **只是检测最基础的类型，对于Object类型的细分无能为力**，比如检测不到数组。然而function有些例外，从技术角度讲，函数在 ECMAScript中是对象，不是一种数据类型。然而，函数也 确实有一些特殊的属性，因此通过 typeof 操作符来区分函数和其他对象是有必要的。那怎么判断数组的类型呢 1. Object.prototype.toString.call() , 2.Array.isArray()

1. "undefined"——如果这个值未定义
```javascript
var a
alert(a) //undefined
typeof undefined // 'undefined'

alert(b) //Reference Error
typeof b //'undefined'
```
因此typeof可以检测两种状态的：
- 未声明
- 未赋值

2. "boolean"——如果这个值是布尔值
3. "string"——如果这个值是字符串
4. "number"——如果这个值是数值
5. "object"——如果这个值是对象（包括Object的派生类）或者null

> typeof 只是检测基础类型其实可以说只是检测


## 三、细说类型

### (1) null 空对象 和 undefined 未定义
> undefined 是 派生于 null 的，它们有许多的共同点，他们最有意思的地方就是被Object排除在外

1. undefined 和 null 的特性
	- 两种种类型各只有一个值：undefined 和 null，undefined 和 null 就既是类型也是值
	- 都没有包装对象（或者说不可生成，应为null本身就是空对象，更别提包装成对象，	undefined派生于null自然和其一个尿性），其实没有Object派生的对应的undefined和null的构造函数，也是证实他们不能转换为对象
	- null == undefined => true；null === undefined => false，相等操作符验证值相等，全等操作符验证类型是否相等

2. 其实真正开发的时候大部分人还是分不清楚null和undefined的，或者说该怎么使用
	- 如果可以，请尽量不要使用undefined类型，即使要判断一个变量可能是undefined也不要尝试和 null相等比较，最简单直接的就是 typeof
	- 事实上没有任何必要给一个变量设置未undefined，如果你觉得声明变量可能有不安全值可以不显示赋值undefined，否则推荐给定初值，这种当typeof一个变量为'undefined'的时候就知道是为声明而不是赋值为undefined
		```javascript
			var number = 0//希望一个数值则给定一个数值初始化
			var string = ''
			var boolean = false
		```
	- 即使真的需要undefined也可能只是在调用函数传递参数是，为了数据配对而被迫的使用undefined实参

		```javascript
		myFun('a', undefined, 'b')
		```
	- null 是当你需要使用一个引用变量的时候，作为初值使用；或者当你不需要使用该应用变量是赋值为null，方便清除对象内存

### (2) Number类型
- 浮点数值
- 数值范围 zhengzhi、Infinity（无穷，分正负）
- NaN 表示“非数值”的一种特殊的数值，注意NaN仍然是一种数值
- 数值转换主要根据Number方法
1. NaN 表示一个本应该返回数值的操作却未返回数值
	- 在进行计算的时候（+、-、*、/、%等）无论和什么值计算都是NaN
	- 在比较的时候是false，总某种意义上说是根据
		```javascript
		NaN == NaN //为false
		```
	  自然的进行比较（>、<、<=、>=等）都是false
	- isNaN函数，表示判断参数是否为能转换为数值且不为NaN

2. Infinity 表示无穷，超出范围
	- 数值计算超出预定返回，返回Infinity，Number.MIN_VALUE、Number.MAX_VALUE：最小最带值
	- Infinity分正负，一个负值*Infinity为-Infinity，同理正值*Infinity为+Infinity
		```javascript
		Infinity == Infinity//true
		-Infinity == +Infinity//false
		Infinity == -Infinity//false
		Infinity == +Infinity//false
		```

### (3) String 类型
- ''单引号、""双引号、``模板字符串
- 转义字符
- 字符串的值是不可变的，"变"只不过是生成新的值，销毁原来的值

### (4) Object类型
```javascript
{
	name: 'WcZix'	
} instanceof Object
```
Object的prototype上有
- constructor 构造函数（当该对象作为原型使用时需要）
- hasOwnProperty(propertyName) 参数是否是该对象自身的属性而不是原型的（和 in 的本质区别在后面一段）
- isPrototypeOf 
- propertyIsEnumerable(propertyName) 属性是否可以枚举，即被for in 遍历获取到
- toString 和 valueOf 是类型转换的时候默认调用的

了解清除toString 和 valueOf 对类型转换非常有用
1. toString、valueOf 表示将该对象转换为字符串使用和转换为数值使用
2. toString、valueOf都是可以被重写的
	```javascript
	const obj = {}
	obj.valueOf = function() {
		return '2' //这里是故意这么写的
	}
	obj.toString = function() {
		return 2 //这里是故意这么写的
	}
	```
3. 但是在真正使用的时候调用方式有很大的区别：
	- 当对象由于外部因素需要转换为数值时：该对象先调用valueOf判断是否返回数值，若不能则调用toString判断能否返回字符串，若能将字符串再次转换为数值
	- 同理，当对象由于外部因素需要转换为字符串时，先toString，再valueOf再转换
	
	```javascript
	//在第2点代码基础上
	1 / obj // 0.5
	1 + obj // '12'
	```
4. 当对象需要Boolean类型的时候，null作用就体现出来了，注意，
	- 所有的非null的对象都是转换为true，这不关乎toString 和 valueOf的事情，这是无法改变的JavaScript定理
	- 但有的时候不需要对象直接转换为布尔值，而是先转换为数值或者字符串再转换为布尔值，这里就不得不体一些Array.prototype.toString是被重写过的，它表现的像这样

		```javascript
		function toString() {
			var result = ''
			for(var i=0; i<this.length; i++) {
				result += this[i] //自动的转换为字符串
			}
			return result
		}
		```
## 四、类型转换

### (1) null 和 undefined
它们在转换为数值和字符串表现不一致
```javascript
Number(undefined) // NaN
Number(null)// 0
String(undefined) // 'undefined'
String(null) // 'null'
```
但是在转换为Boolean一致，都为false

### (2) 数值和字符串
其实上面都说完了其它类型的转换，Object的转换其实最终也体现在数值和字符串的转换，因此几乎可以说数值和字符串的转换在程序中是大量存在的，无论是显式或者隐式，
> 这里就不介绍了，看看书就行，按照标准来，没有太多技巧

## 五、运算符的偏爱类型
> 前面说过对象在转换的时候由外部因素决定，其它类型也是如此。但是这个外部因素究竟是谁？运算符的偏爱类型

### (1) 计算型运算符
- +、-、*、/、%
- --、++		

这些运算符中除了 + ，其它都偏爱数值类型，即Number

**+** 比较特殊，它偏爱字符串，一旦一个操作数是字符串，那么另外一个也要被转换为字符串，如果操作数是对象的话**字符串优先**
```javascript
const obj = {}
obj.valueOf = function() {
	return '2' //这里是故意这么写的
}
obj.toString = function() {
	return 2 //这里是故意这么写的
}
1 + obj // '12'
```
再次看最后一行代码，肯定能感觉到满满的 “不公平”

### (2) 比较型运算符
- \>、>=、<、<= 偏爱数值
- == 比较特殊

== 是相等的意思，那么判别反式就不相同，这就好比你说一个人是不是比另外一个人好，可以从各种角度（类型）出发看，但是说一个人和另外一个人是不是一个人，是完全不同的。

- 两个字符串的相等判断是逐个字符比较
- 一个字符和一个数值，字符转换为数值
	```javascript
	1 == '01' //true
	```
- null和undefined和任何对象或者任何字符串比较为false（null和undefined没有toString方法，其实不能做比较）
- null和undefined在和数值或者布尔时，先转换再比较
- 对象之前用对象地址比较
- 对象和其它类型比较，能转换就比较，不能就false（比如null和undefined）

### (3) 类型转换表
|原始值	|转换为Number	|转换为String	|转换为Boolean
| :--------   | :-----:   | :----: | :----: |
|false	| 0		|"false"	| false
|true	|1		|"true"		|true
|0		|0		|"0"		|false
|1		|1		|"1"		|true
|"0"	|0		|"0"		|true
|"1"	|1		|"1"		|true
|NaN	|NaN	|"NaN"		|false
|Infinity	|Infinity	|"Infinity"		|true
|-Infinity	|-Infinity	|"-Infinity"	|true
|""		|0		|""			|false
|"20"	|20		|"20"		|true
|"twenty"	|NaN		|"twenty"		|true
|[ ]	|0		|""			|true
|[20]	|20		|"20"		|true
|[10,20]	|NaN		|"10,20"		|true
|["twenty"]		|NaN	|"twenty"		|true
|["ten","twenty"]	|NaN	|"ten,twenty"	|true
|function(){}	|NaN	|"function(){}"	|true
|{ }	|NaN	|"[object Object]"	|true
|null	|0	|"null"	|false
|undefined	|NaN	|"undefined"	|false