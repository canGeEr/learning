# 执行上下文和调用栈，以及函数作用域
首先，明确几个问题：
1. js是单线程的 事件循环（event loop） 在浏览器中一个页面永远只有一个线程在执行js脚本代码 
2. js异步执行
```javascript
// test1.js文件
setTimeout(function() {console.log("a")}, 0); //进入事件队列 => 事件循环（event loop）
//它这段代码 其实是在代码的最后执行的
console.log("a之后执行, b");

//test2.js文件
console.log("b之后执行, c");
```

## 一、JS引擎解析的过程 （这里以V8为例 chrome 内核）
JS虽然是解释性语言（编译一句，执行一句，但准确一点的说是边编译，边解析执行。或者运行的时候解析代码），但要注意，很多语言解析器都做过大量的性能优化，不再是纯粹的解释在编译的简单过程

1. JS引擎线程
2. 事件触发线程
3. 定时器触发线程
4. HTTP异步请求线程
5. 事件函数队列

### （一）语法（词法）分析
分析该js脚本代码块的语法是否正确，如果出现不正确会向外抛出一个语法错误（syntaxError），停止改js代码的执行，然后继续查找并加载下一个代码块；如果语法正确，则进入到预编译阶段。
```javascript
// func a() {}; //Uncaught SyntaxError: Unexpected identifier 错误语法
```

### （二）预编译前奏 
确定当前JS执行上下文


### （三）预编译（预解析）
在内存开辟空间，存放变量和函数了。



### （四）执行阶段
执行代码
```javascript
console.log(a);
//test.js:1 Uncaught ReferenceError: a is not defined
```


## 二、细说环境上下文

### （一）执行环境分类
为了和JS的广义的运行环境 =》 运行平台（nodejs，浏览器）冲突理解，特意用JS执行环境，请注意
执行环境一定和函数执行了，函数挂钩。

#### 全局环境 &? 函数环境
js那个函数中执行的代码块的抽象;
其实要真正对全局环境一个定义的话，我更倾向于把整个JS文件看成一个函数，在执行这个JS脚本的时候其实就是调用了这个函数。
那我从哪里可以体现呢
1. 每个环境都对应着一个函数，每个作用域也对应一个函数和函数变量对象，既然存在全局环境和全局对象（变量）window，那么全局函数存在也就十分有可能性
2. 如果通过调试的话，始终可以看见CallBack栈最底有一个叫做anonymous（匿名函数）
3. 在nodejs平台可以打印出arguments，并且通过arguments.callee访问到当前的函数，.name访问名称为空字符串

#### eval环境 
知道有这么回事就行
> 在很多情况下都不推荐使用，一是难用，二是存在安全问题，但并不是说不允许，它有存在的意义，只是在开发中尽量避免这种语法
这已然成为 默认遵守的标准 就想创建函数其实 可以这样写 Function("name","age","console.log("a")")但是都不这么写；另外webapck(支持ES6语法解析打包)和vue都有这样的语法封装




### （二）每个环境对于一个上下文
> console.log 打印一个函数是 调用函数的 toString方法   Function.prototype.toString 重写了 Object.prototype .toString

注意一旦函数创建，函数的作用域就确定了，这点可以很好的区别 调用栈 和 作用域链
用一段代码说明

```javascript
//index.js下
function a() {
  console.log("a执行了");
}
watchFunObj(a);
//也可以直接调出chrome的调试器 注意[[Scopes]]属性 存储的就是函数的作用域

function b() {
  a();
  console.log("b执行了");
  function c() {
    console.log("c执行了");
    watchFunObj(c);
  }
  //执行c
  c();
  //这只是为了看函数的对象模式
  watchFunObj(a);
  
}
//执行b
watchFunObj(b);
//观察函数的对象模式
function watchFunObj(func) {
  // var emptyObj = Object.create(null);
  // emptyObj.func = func;
  // console.log(emptyObj);
  console.log(func.prototype)
}
```
1. 默认的有全局上下文对象，在栈中保存全局环境
```javascript
globalContent = {
  AO: { //这里也常有人为了区分全局环境 叫 GO 注意它就是平时所说的window对象（当然只是地址相同）
    arguments: undefined //默认是 undefined
  },
  Scope: [globalContent.AO],
  this: window
}
```

2. 遇见入函数之后，执行函数之前 创建上下文对象 空对象AO => 变量对象, 作用域链赋值 scope 用arguments创建变量对象
```javascript
aContext = {
  AO:  {
    //注意argument 是最先声明的函数内的变量，甚至快过于函数声明的提升
    //这里也说明了为什么函数内可以直接使用arguments变量
    arguments: {
      ...//函数参数,
      length: Number// 参数的长度
    }
  },
  Scope: [aContext.AO, globalContent.AO],
  this： //调用的时候确定的 谁调用的函数
}
```
3. 处理声明    
(1) 扫描函数的所有形参，并将形参名称 和对应值组成的键值对作为变量对象VO的属性。如果没有传递对应的实参，将undefined作为对应值。如果形参名为arguments，将覆盖arguments（这里和上面执行环境对应）  
(2) 扫描Execution Context中所有的函数声明（注意是函数声明，函数表达式不算）
将函数名和对应值（指向内存中该函数的引用指针）组成组成的键值对作为变量对象VO的属性
如果变量对象VO已经存在同名的属性，则覆盖这个属性  
(3) 扫描Execution Context中所有的变量声明
由变量名和对应值（此时为undefined） 组成，作为变量对象的属性
如果变量名与已经声明的形参或函数相同，此时什么都不会发生，变量声明不会干扰已经存在的这个同名属性。
4. 如果执行函数，将a函数的上下文环境压入栈中。






