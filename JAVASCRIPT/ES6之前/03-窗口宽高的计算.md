# 窗口宽高的计算
我们从大窗口一直计算到小窗口

## 桌面系统的宽高
window.screen 属性，返回值是一个对象，保存着屏幕的信息
- width、height屏幕的宽高
- left、top 浏览器外边离桌面的距离

## 整个浏览器的宽高
Window.outer系列，整个浏览器窗口的宽\高度（单位：像素），包括侧边栏（如果存在）、窗口镶边（window chrome）和窗口调正边框（window resizing borders/handles）
- Window.outerHeight
- Window.outerWidth

## 浏览器窗口宽高
> 真正的网页显示（也叫窗口可见区域）的内容      

- Window.inner系列， 获得浏览器窗口的内容区域的高度，**包含滚动条**(如果有的话)
    - Window.innerHeight
    - Window.innerWidth
- Element.client系列，但是**都不包括滚动条宽高**，它的设计本身就是相对滚动（只显示没有被隐藏和滚动的区域）
    - document.documentElement.clientWidth\Height系列
    - document.body.clientWidth\Height系列

## 获取元素的宽高
> Element.offset系列

- offsetLeft：获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 
- offsetTop：获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置 
- offstParent(表示自己的偏移参考盒子)就是自己祖先元素中，离最近的已经定位的元素。如果自己的祖先元素中，没有任何元素进行了定位，offsetParent对象就是body.

    **注意**：无论元素自身是否定位，该元素的offsetLeft(offsetTop)就是自身到定位的祖先元素的距离值

- offsetWidth = width + 2*padding + 2*borderWidth
- offsetHeight = height + 2*padding + 2*borderWidth

但是大部分的时候，我们只是需要获取元素的content的width和height      

getBoundingClientRect() 返回值是一个对象
- width /height 可视宽高(width/height+padding+border)
- top bottom 元素顶/底部距离可视区顶部的距离
- left right 元素左/右距离可视区左侧的距离

> Element.getClientRects() 也可以同 getBoundingClientRect() ，getBoundingClientRect 是基于 getClientRects实现的

## 关于滚动
- Element.client系列，比之Element.scroll系列少了边框的大小（如果有滚动条减掉滚动条大小）
    ![](https://developer.mozilla.org/@api/deki/files/185/=Dimensions-client.png)
- Element.scroll系列，获取元素的**真实文档的宽高**（不包括滚动条）

scroll系列还有一些属性能够控制滚动
- scrollTop、scrollLeft **读**的时候获取**滚动距离**，**写**的时候滑动滚动条设置滚动距离

- scroll方法可以直接设置滚动到的绝对距离
    ```javascript
    Window.scroll(x, y)//水平x，垂直y
    Window.scroll(option = {
        top: 100,
        left: 100,
        behavior: 'smooth'
    })
    ```
    这个方法和**scrollTo**是一致的，但是推荐使用scrollTo因为更加语义化
- scrollBy方法，在当前偏移位置基础上，再追加偏移
    ```javascript
    window.scrollBy(x, y) 
    // window.scrollBy(option) 
    ```


## getBoundingClientRect 和 offsetTop的区别
- getBoundingClientRect获取到的rect对象的left、top等位置信息都是相对窗口的，而且是window窗口
- offsetTop是元素相对于最近的定位元素 offsetParent的距离，相对top，如果没有最近的，则以body为准。因此对于 offsetTop 它的决定性因素就是 offsetParent




对于一些元素被父元素overflow: 'scroll'之后，元素offsetTop就会无法获取“元素的视觉位置”：即使父元素滚动，元素的offsetTop不变（这点很奇怪，不够MDN解释为，offsetTop为偏移量）


但是getBoundingClientRect这个时候就能获取到准确的相对window的信息，它始终以视觉：人眼看，元素到window的窗口的距离

在不同的应用场景下，我们需要选择不同的属性：但个人感觉getBoundingClientRect更优解，在大部分情况下，**你是不清楚元素的offsetTop的**，而且如果需要计算到window的偏移量，需要循环到最外层，非常不方便