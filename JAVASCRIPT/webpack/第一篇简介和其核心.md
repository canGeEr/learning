# webpack的简介和核心

## 概念
> 注重模块化

本质上，webpack 是一个现代 JavaScript **应用程序的静态模块打包器**(module bundler)。当 webpack 处理应用程序时，它会**递归地构建一个依赖关系图**(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。

## webpack仍然是高度可配置的
在根目录下新建一个webpack.config.js，用于写入用户对webpack的一些配置，如果你对webpack仍然难以理解，你就暂时把它看作一个虚拟的工具，这个工具能帮你整理代码，但是功能繁多，你需要手动配置（告诉它，你需要什么功能，干什么事）。   
了解这些基本概念，可以开始干活了    
1. 新开一个文件夹，命名为learn_webpack

2. 进入该文件夹下得终端，输入指令 生成package.json得包    
```bush
npm init -y
```

3. 安装webpack得依赖包
```bush
npm install webpack webpack-cli -D 
```

3. 在根目录下新建文件夹叫src
4. src文件夹下新建index.js文件

5. 在index.js写入ES6语法，你当然也可以import其它文件
6. 在根目录下得终端，执行打包命令
```bush
npx webppack
```
7. 打包发现多了一个dist文件夹，文件夹下有一个main.js文件，这就是webpack对以src/index.js为入口文件得打包结果（可以注意到，打包得入口文件，生成得文件都是webpack得默认配置，大部分用户都有自己得需求，因此就需要配置文件，配置想要得操作结果导向）

8. npm 脚本
```json
{
  "name": "learnw_webpack",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack" //+
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "webpack": "^4.44.1",
    "webpack-cli": "^3.3.12"
  }
}
```
终端输入命令执行
```bush
npm run build
```

## webpack四个核心概念
- 入口(entry)
- 输出(output)
- loader
- 插件(plugins)

> 说一些题外化，webpack的令我惊讶的在于，它将一些非Javascript得资源，变得可以用javascript处理，本质上webpack是将资源打包形成JS得资源，这些资源全部在一个文件里（如果不需要直接js化得文件，保留，但是在其它资源得连接方式仍然是动态得）

### Entry入口
> 注意，为什么会有entry这个概念，其实程序本质上是顺序执行的，那么肯定有一个入口文件，对于webpack开始来说，要从entry指定的路径开始做“读取”、“翻译”、“打包”的工作。


可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src/index.js


webpack.config.js
```js
module.exports = {
  entry: './src/main.js' //以src下得main.js作为入口文件
};
```


### Output出口
output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist/main.js。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程：   
webpack.config.js
```js
module.exports = {
  entry: './src/main.js', //以src下得main.js作为入口文件
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  }//+
};
```

### Loader加载器
> webpack 自身只理解 JavaScript，这一句很精髓，webpack只是做一个js构建打包得中枢控制器，至于其它类型文件太多，又过于复杂，就交给其它插件或者包去处理


loader 让 webpack 能够去处理那些非 JavaScript 文件（**webpack 自身只理解 JavaScript**）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理    

在更高层面，在 webpack 的配置中 loader 有两个目标：
1. test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。（有一种更取巧得理解方式，test本身就是一个匹配得API，RegExpObject.test(filename)。）
2. use 属性，表示进行转换时，应该使用哪个 loader

webpack.config.js
```js
const path = require('path')

module.exports = {
  entry: './src/main.js', //以src下得main.js作为入口文件
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
      //还有更多配置等待学习
    ]
    //注意rules得规则是从下到上执行得
  }// +
};
```

### Plugins插件
loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。

想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。

webpack.config.js
```js
// 通过 npm 安装
const path = require('path')
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/main.js', //以src下得main.js作为入口文件
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
      //还有更多配置等待学习
    ]
    //注意rules得规则是从下到上执行得
  },// +
  plugins: [
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
}
```


### Model插件

webpack.config.js
```javascript
module.exports = {
  mode: 'production' // 'development'
};
```