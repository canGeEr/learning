
# 01-基本概念的确立（二）

## JS线程是单线程
本身单线程是不存在这个概念，单线程只是相对多线程而存在。或者说JS不是多线程，关于为什么JS不是多线程：

- 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

- 另外一点，就是为了简单，没有DOM临界资源竞争，这也是为后面事件循环EventLoop的出现相互映衬


## 关于EventLoop
它其实在浏览器和NodeJs表现不一致。限于篇幅这里暂时不做过多解释

## 浏览器渲染进程上面提到的各线程，并行？还是并发
1. **假设它是并发，意味着，那些线程都是轮换的占用CPU：**
    - 定时器线程不可能轮换的占用，无法保证计时
    - 现代的CPU大部分，几乎都是多核，为什么非要并发而不是并行，发挥多核的优势，因此并发没有必要
    - 并发，意味着效率低下，前面也说了，JS线程和CUI渲染线程互斥，如果是并发，那就没有互斥的必要啊！ **（互斥，是有临界资源产生竞争）**
2. **假设它是并行，意味着，那些线程都是使用不同核的CPU：**
    - 定时器问题解决
    - CPU利用率高，发挥多核优势
    - JS引擎线程和GUI渲染线程互斥 的 **前提** => **能并行**


> 结论：浏览器渲染进程上面提到的各线程是并行的


**上面解释了，为什么GUI渲染线程要和JS线程竞争**

## 主线程

**一个进程至少有一个线程，即主线程，它是进程的子线程的入口。**      
如果按照这种情况看：浏览器的渲染进程可以分为以下线程
- 主线程 Main thread，运行JavaScript、DOM、CSS、样式布局计算 （渲染线程GUI，JS线程）      
- 工作线程 Worker thread      
- N个工作线程：运行Web Worker，ServiceWorker，Worklet
- 内部线程：Blink和V8会创建几个线程处理web audio，数据库，GC等
    - 排版线程 Compositor thread      
    - 光栅线程 Raster thread      
    - 定时器线程，等等，在进行线程介绍的时候有讲过

> 刚好这也解释了JS线程和GUI线程为什么就是互斥，并且缩短JS线程的执行时间和提高执行效率对页面的展示有帮助

## setTimeOut是什么时候将回调函数放入任务队列的？
答：调用setTimeOut，JS在解析setTimeOut函数时，调用底层接口通知定时器线程开始计时。定时器线程在计时完成，将回调函数放入事件循环任务队列，等待JS线程执行。
```javascript
setTimeout(()=>{
    console.log('a')
}, 2000)
for(let i=0; i<5000000000; i++) {
    1-1 > 2
}
console.log('结束了')
```
这段代码说明setTimeout是在调用了，就开始计时，等到计时完成，直接插入任务队列，等待主线程执行该任务，但是主线程当前的JS代码for循环还未结束，因此等到for循环结束，打印“结束了”，再执行定时器任务前的任务，执行轮询到该定时器任务才打印"a"